!function(t){
	const n = {}; function i(r){
		if (n[r]) return n[r].exports; const e = n[r] = {i:r, l:!1, exports:{}}; return t[r].call(e.exports, e, e.exports, i), e.l = !0, e.exports
	}i.m = t, i.c = n, i.d = function(t, n, r){
		i.o(t, n) || Object.defineProperty(t, n, {enumerable:!0, get:r})
	}, i.r = function(t){
		'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value:'Module'}), Object.defineProperty(t, '__esModule', {value:!0})
	}, i.t = function(t, n){
		if (1 & n && (t = i(t)), 8 & n) return t; if (4 & n && 'object' == typeof t && t && t.__esModule) return t; const r = Object.create(null); if (i.r(r), Object.defineProperty(r, 'default', {enumerable:!0, value:t}), 2 & n && 'string' != typeof t) for (const e in t)i.d(r, e, (n => {
			return t[n]
		}).bind(null, e)); return r
	}, i.n = function(t){
		const n = t && t.__esModule ? function(){
			return t.default
		} : function(){
			return t
		}; return i.d(n, 'a', n), n
	}, i.o = function(t, n){
		return Object.prototype.hasOwnProperty.call(t, n)
	}, i.p = '', i(i.s = 2)
}([function(t, n, i){
	'use strict'; function r(t){
		return function(t){
			if (Array.isArray(t)){
				for (var n = 0, i = new Array(t.length); n < t.length; n++)i[n] = t[n]; return i
			}
		}(t) || function(t){
			if (Symbol.iterator in Object(t) || '[object Arguments]' === Object.prototype.toString.call(t)) return Array.from(t)
		}(t) || function(){
			throw new TypeError('Invalid attempt to spread non-iterable instance')
		}()
	} function e(t, n){
		if (t !== n) throw new TypeError('Cannot instantiate an arrow function')
	} const o = ['index', 'time', '_time', 'mem', 'source']; function s(t){
		return 'string' == typeof t || t instanceof String
	} function u(t){
		const n = t.Error, i = t.frame, u = t.settings, c = t.wSpyParam, a = t.memoryUsage; return {ver:4, logs:{}, otherSpies:[], init:function(){
			if (!this.includeLogs){
				const t = (c || '').split(',').filter(t => {
						return e(this, this), '-' !== t[0]
					}).filter(t => {
						return e(this, this), t
					}), n = (c || '').split(',').filter(t => {
						return e(this, this), '-' === t[0]
					}).map(t => {
						return e(this, this), t.slice(1)
					}); this.includeLogs = u.includeLogs.split(',').concat(t).filter(t => {
					return e(this, this), -1 === n.indexOf(t)
				}).reduce((t, n) => {
					return e(this, this), t[n] = !0, t
				}, {})
			}
		}, shouldLog:function(t, n){
			return Array.isArray(n) && this.includeLogs[t] && !u.extraIgnoredEvents.includes(n[0])
		}, log:function(t, n, i){
			if (this.init(), this.shouldLog(t, n)){
				this.logs.index = this.logs.index || 1, this.logs[t] = this.logs[t] || [], n.index = this.logs.index++, n.source = this.source(i); const r = new Date; n._time = ''.concat(r.getSeconds(), ':').concat(r.getMilliseconds()), n.time = r.getTime(), n.mem = a() / 1e6, this.logs[t].length > u.MAX_LOG_SIZE && (this.logs[t] = this.logs[t].slice(-1 * Math.floor(u.MAX_LOG_SIZE / 2))), !n[0] && n.source && (n[0] = n.source[0]), this.logs[t].push(n)
			}
		}, getCallbackName:function(t, n){
			if (t){
				if (!t.name || s(t.name) && t.name.startsWith('bound ')){
					if (Array.isArray(t.source)) return t.source[0]; const i = this.source(n); if (Array.isArray(i)) return i
				} return t.name.trim()
			}
		}, search:function(t){
			return function(t){
				return '[object RegExp]' === Object.prototype.toString.call(t)
			}(t) ? this.merged(n => {
					return e(this, this), t.test(n.join(' '))
				}) : s(t) ? this.merged(n => {
					return e(this, this), -1 !== n.join(' ').indexOf(t)
				}) : Number.isInteger(t) ? this.merged().slice(-1 * t) : void 0
		}, logCallBackRegistration:function(t, n, i, e){
			t.source = this.source(e), this.log(n, [this.getCallbackName(t, e)].concat(r(i)), e)
		}, logCallBackExecution:function(t, n, i, e){
			this.log(n, [this.getCallbackName(t, e), t.source].concat(r(i)), e)
		}, spyMobx:function(t){
			t.spy(t => {
				if (e(this, this), !t.spyReportEnd && 'update' === t.type){
					const n = this.source(); this.log('mobx', ['update: '.concat(t.name)].concat(r(n), [t.newValue, t]))
				}
			})
		}, purge:function(t){
			const n = -1 * (t || u.DEFAULT_LOGS_COUNT); Object.keys(this.logs).forEach(t => {
				return e(this, this), this.logs[t] = this.logs[t].slice(n)
			})
		}, clear:function(){
			Object.keys(this.logs).forEach(t => {
				return e(this, this), this.logs[t] = []
			})
		}, recent:function(t){
			const n = -1 * (t || u.DEFAULT_LOGS_COUNT); return this.merged().slice(n)
		}, enabled:function(){
			return !0
		}, merged:function(t){
			return [].concat.apply([], Object.keys(this.logs).filter(t => {
				return e(this, this), Array.isArray(this.logs[t])
			}).map(t => {
				return e(this, this), this.logs[t].map(n => {
					e(this, this); const i = [n.index, t].concat(r(n)); return o.forEach(t => {
						e(this, this), i[t] = n[t]
					}), i
				})
			})).filter((n, i, r) => {
				return e(this, this), !t || t(n, i, r)
			}).sort((t, n) => {
				return e(this, this), t.index - n.index
			})
		}, grouped:function(t){
			const n = this.merged(t), i = -1 * u.DEFAULT_LOGS_COUNT; return [].concat.apply([], n.reduce((t, n, i, o) => {
				e(this, this); const s = t[t.length - 1]; return s ? (n[1] === s[0][1] ? s.push(n) : (s.length > u.GROUP_MIN_LEN && s.unshift('['.concat(s.length, '] ').concat(s[0][1])), t.push(r(n))), i === o.length - 1 && s.length > u.GROUP_MIN_LEN && s.unshift('['.concat(s.length, '] ').concat(s[0][1])), t) : [r(n)]
			}, []).map(t => {
				return e(this, this), t.length > u.GROUP_MIN_LEN ? [t] : t
			})).slice(i).map((t, n, i) => {
				e(this, this); const r = 0 === n ? 0 : t.time - i[n - 1].time; return t[0] = ''.concat(t[0], ' +').concat(r), t
			}); function r(t){
				const n = [t]; return n.time = t.time, n
			}
		}, groupedNoMobx:function(t){
			return this.grouped((n, i, r) => {
				return e(this, this), 'mobx' !== n[1] && (!t || t(n, i, r))
			})
		}, source:function(t){
			n.stackTraceLimit = 50; for (var o = [i]; o[0].parent && o[0] !== o[0].parent;)o.unshift(o[0].parent); let s = o.reverse().map(t => {
				return e(this, this), (new t.Error).stack
			}).join('\n').split(/\r|\n/).map(t => {
				return e(this, this), t.trim()
			}).slice(4).filter(t => {
				return e(this, this), 'Error' !== t
			}).filter(t => {
				return e(this, this), !u.stackFilter.test(t)
			}); if (t){
				const c = s.findIndex(n => {
					return e(this, this), -1 !== n.indexOf(t)
				}); s = s.slice(c + 1)
			} const a = s[0] || ''; return [a.split(/at |as /).pop().split(/ |]/)[0], a.split('/').pop().slice(0, -1).trim()].concat(r(s))
		}}
	}t.exports = {init:function(t){
		return e(this, this), u(t)
	}.bind(this)}
}, function(t, n){
	function i(){}t.exports = {defaultSettings:{moreLogs:'', includeLogs:'', extraIgnoredEvents:[], MAX_LOG_SIZE:1e4, DEFAULT_LOGS_COUNT:300, GROUP_MIN_LEN:5, stackFilter:/wSpy/i}, noopSpy:{init:i, shouldLog:i, log:i, getCallbackName:i, search:i, logCallBackRegistration:i, logCallBackExecution:i, spyMobx:i, enabled:i, isActive:i}}
}, function(t, n, i){
	t.exports = i(3)
}, function(t, n, i){
	function r(t, n){
		if (t !== n) throw new TypeError('Cannot instantiate an arrow function')
	} const e = i(4), o = i(5); t.exports = {initBrowserHost:function(t){
		return r(this, this), e.init(t)
	}.bind(this), initWorkerHost:function(t){
		return r(this, this), o.init(t)
	}.bind(this)}
}, function(t, n, i){
	'use strict'; function r(t){
		return function(t){
			if (Array.isArray(t)){
				for (var n = 0, i = new Array(t.length); n < t.length; n++)i[n] = t[n]; return i
			}
		}(t) || function(t){
			if (Symbol.iterator in Object(t) || '[object Arguments]' === Object.prototype.toString.call(t)) return Array.from(t)
		}(t) || function(){
			throw new TypeError('Invalid attempt to spread non-iterable instance')
		}()
	} const e = i(0), o = i(1), s = o.defaultSettings, u = o.noopSpy; function c(){
		return 'undefined' != typeof window && void 0 !== window.parent
	}t.exports = {init:function(t){
		const n = t.wSpyOverrideParam, i = t.settings; try {
			const o = c(), a = n || function(t){
				if ('undefined' != typeof URL){
					const n = new URL(t); return n.searchParams.get('wspy') || n.searchParams.get('wSpy')
				}
			}(window.parent.location.href); if (!a || !o) return u; const h = e.init({Error:window.Error, memoryUsage:function(){
					return function(t, n){
						if (t !== n) throw new TypeError('Cannot instantiate an arrow function')
					}(this, this), (t = window.performance) && t.memory && t.memory.usedJSHeapSize || 0; let t
				}.bind(this), frame:window, wSpyParam:a, settings:Object.assign({}, s, i)}), f = function(){
					try {
						return c() && void 0 !== window.parent.wSpy && window.parent.wSpy
					} catch (t){
						return null
					}
				}(); return f ? (h.initStack = (new Error).stack, h.logs = f.logs || h.logs, (f.ver || 0) < h.ver ? (f.logs = h.logs, h.otherSpies = [f].concat(r(f.otherSpies || [])), window.parent.wSpy = h) : f.otherSpies.push(h), h) : o ? (window.parent.wSpy = h, h.initStack = (new Error).stack, h) : u
		} catch (t){
			return u
		}
	}}
}, function(t, n, i){
	'use strict'; const r = i(0), e = i(1), o = e.defaultSettings, s = e.noopSpy; t.exports = {init:function(t){
		const n = t.wSpyOverrideParam, i = t.settings; try {
			return n ? r.init({Error:'undefined' != typeof self ? self.Error : {}, memoryUsage:function(){
				return function(t, n){
					if (t !== n) throw new TypeError('Cannot instantiate an arrow function')
				}(this, this), 0
			}.bind(this), frame:'undefined' != typeof self ? self : {}, wSpyParam:n, settings:Object.assign({}, o, i)}) : s
		} catch (t){
			return s
		}
	}}
}])